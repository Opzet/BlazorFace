@inherits ChooseSingleImageBase

@using FaceAiSharp;
@using FaceAiSharp.Extensions;
@using SixLabors.ImageSharp.Drawing.Processing;
@using SixLabors.ImageSharp.PixelFormats;
@using BlazorFace.Components
@using BlazorFace.Services

@inject IJSRuntime JS
@inject ObjectPool<IFaceDetectorWithLandmarks> detectorPool

<style>
    .img-overlay-wrap {
        position: relative;
        display: inline-block; /* shrinks container to image size */
        transition: transform 150ms ease-in-out;
    }

        .img-overlay-wrap .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
        }
</style>

<div class="d-flex flex-row align-items-center justify-content-center row mb-3">
    <span class="col-12 col-sm-auto mb-2 mb-sm-0 text-center">Bounding Box Color:</span>
    <MultiChoiceRadio Class="col-auto" Choices="@(new[] {Yellow, Red, Blue, Green})" @bind-SelectedChoice="@_bboxColorString" />
</div>

<p class="d-flex flex-row align-items-center row justify-content-center">
    <div class="col-12 col-sm-8 col-lg-4">
        @{
            var thresholdId = Guid.NewGuid().ToString("n");
        }
        <label for="@thresholdId" class="form-label">Detection Threshold: @_detectionThreshold.ToString("0.00")</label>
        <input
            @bind-value="@_detectionThreshold"
            @bind-value:event="oninput"
            @bind-value:culture="@System.Globalization.CultureInfo.InvariantCulture"
            type="range" class="form-range" min="0.01" max="1.0" step="0.01" id="@thresholdId">
    </div>
</p>

@{
    base.BuildRenderTree(__builder);
}

<div class="d-flex flex-row justify-content-center mt-3 restrict-child-image-size">
    <div class="img-overlay-wrap">
        <img id="@imgId" class="mw-100" />
        @if (_rectangles != null && _rectangles.Any())
        {
            var strokeWidth = Math.Max(_viewbox.Width / 400.0, 1.0);
            @((MarkupString)SvgDrawer.DrawRectangles(_viewbox, strokeWidth, _rectangles, $"class=\"overlay\" style=\"color: #{_bboxColor.ToHex()}\""))
        }
    </div>
</div>

@code {
    private const string Yellow = nameof(Yellow);
    private const string Red = nameof(Red);
    private const string Blue = nameof(Blue);
    private const string Green = nameof(Green);

    private readonly string imgId = Guid.NewGuid().ToString("n");

    private float _detectionThreshold = 0.5f;

    private string _bboxColorString = Yellow;
    private Color _bboxColor => _bboxColorString switch
    {
        Red => Color.Red,
        Yellow => Color.Yellow,
        Blue => Color.DeepSkyBlue,
        Green => Color.LimeGreen,
        _ => throw new NotImplementedException(),
    };

    private List<Rectangle> _rectangles = new();
    private Rectangle _viewbox;

    protected override async Task Clear()
    {
        await base.Clear();
        await JS.ClearImage(imgId);
        _rectangles.Clear();
    }

    protected override async Task<string?> OnImageLoadedAsync(Image<Rgb24> image)
    {
        var det = detectorPool.Get();

        try
        {
            int Detect()
            {
                var scrfd = (FaceAiSharp.ScrfdDetector)det;
                var old = scrfd.Options.ConfidenceThreshold;
                scrfd.Options.ConfidenceThreshold = _detectionThreshold;
                var detections = det.DetectFaces(image);
                scrfd.Options.ConfidenceThreshold = old;
                _rectangles = detections.Where(x => x.Confidence >= _detectionThreshold).Select(x => Rectangle.Round(x.Box)).ToList();
                _viewbox = new Rectangle(0, 0, image.Width, image.Height);
                return detections.Count;
            }
#if ANDROID
            var cnt = await Task.Run(Detect);
#else
            var cnt = Detect();
#endif
            await JS.SetImageStream(image, imgId);
            StateHasChanged();

            return cnt > 0 ? null : "No faces could be found in this image.";
        }
        finally
        {
            detectorPool.Return(det);
        }
    }
}
